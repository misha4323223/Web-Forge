Понял! Для продакшена на Яндекс Cloud нужно сохранить credentials в переменных окружения Cloud Function. Сейчас создам систему авторизации, которая работает и в Replit (для разработки), и в Yandex Cloud (для продакшена).

I need to implement authentication for the admin panel. For Yandex Cloud deployment, the credentials will be stored in Cloud Function environment variables. For Replit development, they'll be in secrets.

The approach:

Create a login page/state in Admin.tsx
Add an auth endpoint in server/routes.ts
Use session-based auth or simple token-based auth
Since it's a static site deployed to Yandex Object Storage, the auth needs to work client-side with the Cloud Function validating credentials. Let me implement:

A login form in Admin.tsx that shows before the admin content
Store auth state in localStorage/sessionStorage
Backend endpoint to validate credentials
For simplicity and security, I'll:

Add login state to Admin.tsx with a login form
Call Cloud Function to validate credentials
Store session token in sessionStorage
Создам защиту админки с формой входа. Credentials будут проверяться через Cloud Function (для продакшена на Яндекс Cloud).

I need to add an authentication layer to the Admin page. I'll:

Add isAuthenticated state
Create a login form
Check credentials against environment variables4. Store auth token in sessionStorage
Let me read more of the Admin.tsx file to see where the main content starts, then add the auth logic.

Now I understand the structure of Admin.tsx. I need to add authentication before showing the content. I'll:1. Add isAuthenticated state (check sessionStorage on load)2. Add login form at the beginning3. If not authenticated, show login form; otherwise, show the admin content4. Add API endpoint for login validationLet me now modify Admin.tsx to add authentication. I'll add a login form component before the main content.

-2
+2
-1
+1
import { useState } from "react";
import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation, useQuery } from "@tanstack/react-query";
-1
+1
import { Badge } from "@/components/ui/badge";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog";
import { Loader2, Copy, Check, Trash2, Edit2, Mail, Phone, Calendar, StickyNote, Building2, CreditCard, FileText, CheckCircle } from "lucide-react";
import { Loader2, Copy, Check, Trash2, Edit2, Mail, Phone, Calendar, StickyNote, Building2, CreditCard, FileText, CheckCircle, Lock, LogOut, Eye, EyeOff } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
type AdditionalInvoiceFormData = {
Теперь добавлю логику авторизации в компонент:

-0
+69
-0
+69
  const [orderToDelete, setOrderToDelete] = useState<Order | null>(null);
  const [noteText, setNoteText] = useState("");
  const [activeTab, setActiveTab] = useState("orders");

  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [loginEmail, setLoginEmail] = useState("");
  const [loginPassword, setLoginPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [loginLoading, setLoginLoading] = useState(false);
  const [authChecking, setAuthChecking] = useState(true);
  const API_BASE_URL = import.meta.env.VITE_API_URL || "https://functions.yandexcloud.net/d4ed08qj9rekklj8b100";

  useEffect(() => {
    const token = sessionStorage.getItem("adminToken");
    if (token) {
Теперь добавлю интерфейс входа. Найду место где начинается return:

-1
+94
-1
+94
    toast({ title: "ID скопирован!", description: orderId });
  };
  if (authChecking) {
    return (
      <div className="min-h-screen bg-background text-foreground flex items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-cyan-400" />
      </div>
    );
  }
  if (!isAuthenticated) {
    return (
      <div className="min-h-screen bg-background text-foreground">
        <Navigation />
        <main className="pt-24 pb-16">
Отлично! Теперь добавлю обработку авторизации в Cloud Function. Сначала проверю текущую структуру:

I need to add admin authentication to the Cloud Function. The token in sessionStorage is not ideal but for a static site it's a practical solution. I'll:1. Create a secure token by hashing credentials + timestamp2. Set a short expiration on the token (1 hour)3. Verify the token on each API call

Let me add the admin-login and verify-admin handlers to the Cloud Function. I'll also add ADMIN_EMAIL and ADMIN_PASSWORD as environment variables that will need to be configured in Yandex Cloud.

Now I need to add the admin authentication handlers. Let me add them after the existing routes.

-0
+9
-0
+9
        const actionOrderMatch = action.match(/^orders\/([a-zA-Z0-9_-]+)$/);
        if (actionOrderMatch && method === 'GET') {
            return await handleGetOrder(actionOrderMatch[1], headers);
        }

        // Admin authentication
        if (action === 'admin-login' && method === 'POST') {
            return await handleAdminLogin(body, headers);
        }

        if (action === 'verify-admin' && method === 'POST') {
            return await handleVerifyAdmin(body, headers);
        }
        // DELETE /api/orders/:orderId - мягкое удаление заказа
Now I need to add the actual handler functions for admin login and token verification. Let me find where to add them in the file - I'll look for where other handler functions are defined.

Теперь добавлю функции обработки авторизации. Найду место в конце файла:

Добавлю защищённые функции авторизации с JWT-подобными токенами:

-0
+91
-0
+91
    }
}
// Admin Authentication with HMAC-signed tokens
const ADMIN_TOKEN_SECRET = process.env.ADMIN_TOKEN_SECRET || 'mp-webstudio-admin-secret-2024';
const TOKEN_EXPIRY_HOURS = 24;
function generateAdminToken() {
    const now = Date.now();
    const expiry = now + (TOKEN_EXPIRY_HOURS * 60 * 60 * 1000);
    const payload = JSON.stringify({ exp: expiry, iat: now, role: 'admin' });
    const payloadBase64 = Buffer.from(payload).toString('base64url');
    const signature = crypto.createHmac('sha256', ADMIN_TOKEN_SECRET)
        .update(payloadBase64)
        .digest('base64url');
    return `${payloadBase64}.${signature}`;
Исправлю проблему с timingSafeEqual (требует одинаковую длину буферов):

-4
+10
-4
+10
    }

    // Constant-time comparison to prevent timing attacks
    const emailMatch = email && adminEmail && 
        crypto.timingSafeEqual(Buffer.from(email.toLowerCase()), Buffer.from(adminEmail.toLowerCase()));
    const passwordMatch = password && adminPassword && 
        crypto.timingSafeEqual(Buffer.from(password), Buffer.from(adminPassword));
    const safeCompare = (a, b) => {
        if (!a || !b) return false;
        const bufA = Buffer.from(a);
        const bufB = Buffer.from(b);
        if (bufA.length !== bufB.length) return false;
        return crypto.timingSafeEqual(bufA, bufB);
    };

    const emailMatch = safeCompare(email?.toLowerCase(), adminEmail?.toLowerCase());
Теперь добавлю обработку авторизации на сервере разработки (routes.ts) для тестирования в Replit:

I need to add the admin auth routes to server/routes.ts before return httpServer;. Let me add them there.

-0
+80
-0
+80
    }
  });
  // Admin Authentication
  const ADMIN_TOKEN_SECRET = process.env.ADMIN_TOKEN_SECRET || 'mp-webstudio-admin-secret-2024';
  const TOKEN_EXPIRY_HOURS = 24;
  function generateAdminToken(): string {
    const now = Date.now();
    const expiry = now + (TOKEN_EXPIRY_HOURS * 60 * 60 * 1000);
    const payload = JSON.stringify({ exp: expiry, iat: now, role: 'admin' });
    const payloadBase64 = Buffer.from(payload).toString('base64url');
    const signature = crypto.createHmac('sha256', ADMIN_TOKEN_SECRET)
      .update(payloadBase64)
      .digest('base64url');
    return `${payloadBase64}.${signature}`;
Now I need to update the Admin.tsx to also call the local API endpoints when in development mode, not just the Yandex Cloud Function. Let me update the auth functions to use the correct API paths.

Actually looking at the Admin.tsx code, the login calls to ${API_BASE_URL}?action=admin-login and ${API_BASE_URL}?action=verify-admin. For the local dev server, we need to call /api/admin-login and /api/verify-admin.Let me check the logic and update it to use local endpoints when VITE_API_URL is not set.

Теперь нужно обновить Admin.tsx чтобы использовать локальные API в режиме разработки:

-2
+10
-1
+6
    }
  }, []);

  const isProduction = !!import.meta.env.VITE_API_URL;

  const verifyToken = async (token: string) => {
    try {
      const res = await fetch(`${API_BASE_URL}?action=verify-admin`, {
      const url = isProduction 
        ? `${API_BASE_URL}?action=verify-admin`
        : "/api/verify-admin";
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ token }),
Now I need to set the admin credentials in Replit secrets for development testing. Then I should update replit.md to document this security improvement. Let me restart the workflow and check that everything is working.

Теперь сохраню учётные данные в Replit secrets для разработки и обновлю документацию:

Для защиты админки добавьте учётные данные:

ADMIN_EMAIL: Pimashin2015@gmail.com
ADMIN_PASSWORD: 119944Alisa

Эти данные будут храниться безопасно. Для Яндекс Cloud нужно будет добавить эти же переменные в настройки Cloud Function.

2 secrets requested
•
ADMIN_EMAIL
ADMIN_PASSWORD